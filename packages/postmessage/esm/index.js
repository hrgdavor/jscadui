var S=1,u=new Map,w="__RESPONSE__",M=Symbol.for("__transferable__"),p=(s,a)=>(s[M]=a,s),E=s=>s?s.map(a=>a.buffer||a):[],b=(s,a,{onJobCount:l}={})=>{let i=s.postMessage?s:s.controller,m=(e,t)=>{let o=e?.[M];o&&delete e[M];try{i.postMessage({method:w,params:e,id:t},E(o))}catch(r){throw console.error("failed to send ",e,o),r}},g=(e,t)=>{try{let o=e.stack;i.postMessage({method:w,error:e,stack:o,id:t})}catch(o){throw console.error("failed to send ",o),o}},y=(e,t=[],o=[])=>{i.postMessage({method:e,params:t},E(o))},d=(e,t=[],o=[],r)=>{let f=S++;return i.postMessage({method:e,params:t,id:f},E(o)),new Promise((h,n)=>{u.set(f,[h,n]),l?.(u.size),r&&setTimeout(()=>{n("timeout")},r)})},c=async e=>{let{method:t,params:o,id:r,error:f,stack:x}=e.data;if(r&&t===w){let n=u.get(r);if(!n)return console.error(`req ${r} not found`,r,e.data,e);u.delete(r),l?.(u.size);let[R,_]=n;f?(f.stack=x,_(f)):R(o);return}let h=a[t];if(!h){let n="no handler for type: "+t;throw console.error(n,e),new Error(n)}try{let n=await h(...o);r&&m(n,r)}catch(n){console.error(`error executing command ${t}`,o,n),g(n,r)}};return s.addEventListener?.("message",c),{sendCmd:d,sendNotify:y,sendResponse:m,sendError:g,listener:c,self:s,getRpcJobCount:()=>u.size}},N=(s,a,{sender:l,onJobCount:i})=>{let{sendCmd:m,sendNotify:g,getRpcJobCount:y}=l||b(s,a,{onJobCount:i});return new Proxy({getRpcJobCount:y},{get(d,c,e){return c in d?d[c]:c.startsWith("on")?d[c]=function(...t){g(c,t)}:d[c]=function(...t){return m(c,t)}}})};export{b as initMessaging,N as messageProxy,p as withTransferable};
//# sourceMappingURL=index.js.map
