{
  "version": 3,
  "sources": ["../index.js"],
  "sourcesContent": ["let seq = 1\r\nlet reqMap = new Map()\r\nconst RESPONSE = '__RESPONSE__'\r\nconst TRANSFERABLE = Symbol.for('__transferable__')\r\n\r\nexport const withTransferable = (params,trans)=>{\r\n  params[TRANSFERABLE] = trans\r\n  return params\r\n}\r\n\r\nconst fixTransfer = trans => (trans ? trans.map(a => a.buffer || a) : [])\r\n\r\n/**\r\n *\r\n * @param {*} _self reference to self of the main window (self) or reference to a worker\r\n * @param {*} handlers - object where key if method name, and value ih handler\r\n * @returns\r\n */\r\nexport const initMessaging = (_self, handlers, {onJobCount}={}) => {\r\n  // on service worker, postMessage is on the controller\r\n  const ___self = _self.postMessage ? _self : _self.controller\r\n  const sendResponse = (result, id) => {\r\n    let trans = result?.[TRANSFERABLE]\r\n    if (trans) {\r\n      delete result[TRANSFERABLE]\r\n    }\r\n    try {\r\n      ___self.postMessage({ method: RESPONSE, params: result, id }, fixTransfer(trans))\r\n      \r\n    } catch (error) {\r\n      console.error('failed to send ', result, trans)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  const sendError = (error, id) => {\r\n    try {\r\n      // serialize stacktrace so it isn't lost in transit\r\n      const stack = error.stack\r\n      ___self.postMessage({ method: RESPONSE, error, stack, id })\r\n    } catch (error) {\r\n      console.error('failed to send ', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message with no response\r\n   *\r\n   * @param {string} method\r\n   * @param {object} params\r\n   * @param {Array} trans\r\n   */\r\n  const sendNotify = (method, params = [], trans = []) => {\r\n    ___self.postMessage({ method, params }, fixTransfer(trans))\r\n  }\r\n\r\n  /**\r\n   * Send a message with response expected\r\n   *\r\n   * @param {string} method\r\n   * @param {object} params\r\n   * @param {Array} trans\r\n   * @param {number?} timeout\r\n   * @returns {Promise} resolves when response is received\r\n   */\r\n  const sendCmd = (method, params = [], trans = [], timeout) => {\r\n    const id = seq++\r\n    ___self.postMessage({ method, params, id }, fixTransfer(trans))\r\n\r\n    const out = new Promise((resolve, reject) => {\r\n      reqMap.set(id, [resolve, reject])\r\n      onJobCount?.(reqMap.size)\r\n      if (timeout) {\r\n        setTimeout(() => {\r\n          reject('timeout')\r\n        }, timeout)\r\n      }\r\n    })\r\n    return out\r\n  }\r\n\r\n  const listener = async (e) => {\r\n    const { method, params, id, error, stack } = e.data\r\n    if (id && method === RESPONSE) {\r\n      const p = reqMap.get(id)\r\n\r\n      if (!p) return console.error(`req ${id} not found`,id, e.data, e)\r\n      reqMap.delete(id)\r\n      onJobCount?.(reqMap.size)\r\n\r\n      const [resolve, reject] = p\r\n      if (error) {\r\n        // restore stacktrace\r\n        error.stack = stack\r\n        reject(error)\r\n      } else {\r\n        resolve(params)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    const fn = handlers[method]\r\n    if (!fn) {\r\n      const msg = 'no handler for type: ' + method\r\n      console.error(msg, e)\r\n      throw new Error(msg)\r\n    }\r\n    try {\r\n      const out = await fn(...params)\r\n      if (id) {\r\n        sendResponse(out, id)\r\n      }\r\n    } catch (error) {\r\n      console.error(`error executing command ${method}`, params, error)\r\n      sendError(error, id)\r\n    }\r\n  }\r\n  \r\n  _self.addEventListener?.('message', listener)\r\n\r\n  return { \r\n    sendCmd, \r\n    sendNotify, \r\n    sendResponse, \r\n    sendError, \r\n    listener, \r\n    self:_self, \r\n    getRpcJobCount:()=>reqMap.size \r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} _self \r\n * @param {*} handlers \r\n * @returns {object}\r\n*/\r\nexport const messageProxy = (_self, handlers, {sender, onJobCount}) => {\r\n  const { sendCmd, sendNotify, getRpcJobCount} = sender || initMessaging(_self, handlers,{onJobCount})\r\n\r\n  return new Proxy({\r\n    getRpcJobCount\r\n  },{\r\n    get(target, prop, receiver) {\r\n      if(prop in target)  return target[prop]\r\n      if(prop.startsWith('on')){\r\n        return target[prop] = function(...params){\r\n          sendNotify(prop, params)\r\n        }  \r\n      }\r\n      return target[prop] = function(...params){\r\n        return sendCmd(prop, params)\r\n      }\r\n    },\r\n  })\r\n}\r\n"],
  "mappings": "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",
  "names": ["seq", "reqMap", "RESPONSE", "TRANSFERABLE", "withTransferable", "params", "trans", "fixTransfer", "initMessaging", "_self", "handlers", "onJobCount", "___self", "sendResponse", "result", "id", "error", "sendError", "stack", "sendNotify", "method", "sendCmd", "timeout", "resolve", "reject", "listener", "p", "fn", "msg", "out", "messageProxy", "sender", "getRpcJobCount", "target", "prop", "receiver"]
}
